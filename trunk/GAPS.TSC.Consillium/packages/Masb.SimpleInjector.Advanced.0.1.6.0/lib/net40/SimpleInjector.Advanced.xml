<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SimpleInjector.Advanced</name>
    </assembly>
    <members>
        <member name="T:SimpleInjector.Advanced.Core.AppSettingsConvention">
            <summary>
            A convention to inject a value from the Application Settings configuration section,
            when the parameter name of the constructor end with "AppSetting" postfix.
            </summary>
        </member>
        <member name="T:SimpleInjector.Advanced.Core.IParameterConvention">
            <summary>
            Represents constructor parameter injection by using conventions,
            base on <see cref="T:System.Reflection.ParameterInfo"/>'s of the constructor.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.IParameterConvention.CanResolve(System.Reflection.ParameterInfo)">
            <summary>
            Returns a value indicating whether an <see cref="C:Expression"/> can be built and injected
            through the given <see cref="C:ParameterInfo"/> that represents a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>True if an <see cref="C:Expression"/> can be built and injected through a given constructor parameter.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.IParameterConvention.BuildExpression(System.Reflection.ParameterInfo)">
            <summary>
            Returns an <see cref="C:Expression"/> from a <see cref="C:ParameterInfo"/> representing a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>An <see cref="C:Expression"/> that when compiled returns the value to inject into the constructor parameter.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.AppSettingsConvention.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.Advanced.Core.AppSettingsConvention"/> class.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.AppSettingsConvention.#ctor(System.Func{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.Advanced.Core.AppSettingsConvention"/> class.
            </summary>
            <param name="applicationSettingsReader">
            An application settings reader delegate, that can change the default behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            When <paramref name="applicationSettingsReader"/> is null.
            </exception>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.AppSettingsConvention.CanResolve(System.Reflection.ParameterInfo)">
            <summary>
            Returns a value indicating whether an <see cref="C:Expression"/> can be built and injected
            through the given <see cref="C:ParameterInfo"/> that represents a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>True if an <see cref="C:Expression"/> can be built and injected through a given constructor parameter.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.AppSettingsConvention.BuildExpression(System.Reflection.ParameterInfo)">
            <summary>
            Returns an <see cref="C:Expression"/> from a <see cref="C:ParameterInfo"/> representing a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>An <see cref="C:Expression"/> that when compiled returns the value to inject into the constructor parameter.</returns>
        </member>
        <member name="T:SimpleInjector.Advanced.Core.ConnectionStringsConvention">
            <summary>
            A convention to inject a value from the Connection Strings configuration section,
            when the parameter name of the constructor end with "ConnectionString" postfix.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.ConnectionStringsConvention.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.Advanced.Core.ConnectionStringsConvention"/> class.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.ConnectionStringsConvention.#ctor(System.Func{System.String,System.Configuration.ConnectionStringSettings})">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleInjector.Advanced.Core.ConnectionStringsConvention"/> class.
            </summary>
            <param name="connectionStringReader">
            A connection string reader delegate, that can change the default behavior.
            </param>
            <exception cref="T:System.ArgumentNullException">
            When <paramref name="connectionStringReader"/> is null.
            </exception>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.ConnectionStringsConvention.CanResolve(System.Reflection.ParameterInfo)">
            <summary>
            Returns a value indicating whether an <see cref="C:Expression"/> can be built and injected
            through the given <see cref="C:ParameterInfo"/> that represents a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>True if an <see cref="C:Expression"/> can be built and injected through a given constructor parameter.</returns>
        </member>
        <member name="M:SimpleInjector.Advanced.Core.ConnectionStringsConvention.BuildExpression(System.Reflection.ParameterInfo)">
            <summary>
            Returns an <see cref="C:Expression"/> from a <see cref="C:ParameterInfo"/> representing a constructor parameter.
            </summary>
            <param name="parameter">A <see cref="C:ParameterInfo"/> representing a constructor parameter to inject a value to.</param>
            <returns>An <see cref="C:Expression"/> that when compiled returns the value to inject into the constructor parameter.</returns>
        </member>
        <member name="T:SimpleInjector.Advanced.Extensions.ContainerExtensions">
            <summary>
            Advanced Simple Injector container extension methods that allow advanced registration scenarios.
            </summary>
        </member>
        <member name="M:SimpleInjector.Advanced.Extensions.ContainerExtensions.RegisterWithContext``1(SimpleInjector.Container,System.Func{SimpleInjector.Advanced.Core.DependencyContext,``0})">
            <summary>
                Registers the specified delegate <paramref name="contextBasedFactory"/> that will produce instances of
            type <typeparamref name="TService"/> and will be returned when an instance of type
            <typeparamref name="TService"/> is requested.
                Be aware that by using this registration method,
            you are probably not following the best practices, like SOLID and DRY.
                Read remarks for more information.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="container">The container in which the service will be registered.</param>
            <param name="contextBasedFactory">The delegate that allows building or creating new instances.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, 
            or when the <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when one of the supplied arguments is a null reference (Nothing in VB).
            </exception>
            <remarks>
            <para>
            This code is based on a code snippet from SimpleInjector:
            <a href="https://simpleinjector.codeplex.com/wikipage?title=ContextDependentExtensions&amp;referringTitle=Advanced-scenarios">
            ContextDependentExtensions
            </a>
            </para>
            <para>
            Note that the use of this method is not encouraged.
            When you use this method, it is most probably an indication that you are not following
            design principles like SOLID and DRY.
            </para>
            <para>
            <h2>Information about these principles</h2>
            <ul>
            <li> <a href="http://stackoverflow.com/questions/9892137/windsor-pulling-transient-objects-from-the-container/9915056#9915056">
            Do I log too much? Do I violate the SOLID principles?
            </a> </li>
            <li> <a href="https://simpleinjector.codeplex.com/wikipage?title=Advanced-scenarios&amp;referringTitle=Advanced-scenarios&amp;ANCHOR#Context-Based-Injection">
            Context Based Injection
            </a> </li>
            <li> <a href="http://en.wikipedia.org/wiki/SOLID">
            SOLID (object-oriented design)
            </a> </li>
            </ul>
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Advanced.Extensions.ContainerExtensions.RegisterWithContext``1(SimpleInjector.Container,System.Func{SimpleInjector.Advanced.Core.DependencyContext,``0},SimpleInjector.Lifestyle)">
            <summary>
                Registers the specified delegate <paramref name="contextBasedFactory"/> that will produce instances of
            type <typeparamref name="TService"/> and will be returned when an instance of type
            <typeparamref name="TService"/> is requested. The delegate is expected to produce new instances on
            each call. The instances are cached according to the supplied <paramref name="lifestyle"/>,
            and also cached by context `ImplementationType` property.
                Be aware that by using this registration method,
            you are probably not following the best practices, like SOLID and DRY.
                Read remarks for more information.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="container">The container in which the service will be registered.</param>
            <param name="contextBasedFactory">The delegate that allows building or creating new instances.</param>
            <param name="lifestyle">The lifestyle that specifies how the returned instance will be cached.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, 
            or when the <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when one of the supplied arguments is a null reference (Nothing in VB).
            </exception>
            <remarks>
            <para>
            Note that the use of this method is not encouraged.
            When you use this method, it is most probably an indication that you are not following
            design principles like SOLID and DRY.
            </para>
            <para>
            <h2>Information about these principles</h2>
            <ul>
            <li> <a href="http://stackoverflow.com/questions/9892137/windsor-pulling-transient-objects-from-the-container/9915056#9915056">
            Do I log too much? Do I violate the SOLID principles?
            </a> </li>
            <li> <a href="https://simpleinjector.codeplex.com/wikipage?title=Advanced-scenarios&amp;referringTitle=Advanced-scenarios&amp;ANCHOR#Context-Based-Injection">
            Context Based Injection
            </a> </li>
            <li> <a href="http://en.wikipedia.org/wiki/SOLID">
            SOLID (object-oriented design)
            </a> </li>
            </ul>
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Advanced.Extensions.ContainerExtensions.RegisterSingleWithContext``1(SimpleInjector.Container,System.Func{SimpleInjector.Advanced.Core.DependencyContext,``0})">
            <summary>
                Registers the specified delegate <paramref name="contextBasedFactory"/> that will produce instances of
            type <typeparamref name="TService"/> and will be returned when an instance of type
            <typeparamref name="TService"/> is requested. 
            The delegate is expected to produce new instances on each call.
            This delegate will be called at most once per context `ImplementationType` during the lifetime of the application.
            The returned instance must be thread-safe when working in a multi-threaded environment.
                Be aware that by using this registration method,
            you are probably not following the best practices, like SOLID and DRY.
                Read remarks for more information.
            </summary>
            <typeparam name="TService">The interface or base type that can be used to retrieve instances.</typeparam>
            <param name="container">The container in which the service will be registered.</param>
            <param name="contextBasedFactory">The delegate that allows building or creating new instances.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this container instance is locked and can not be altered, 
            or when the <typeparamref name="TService"/> has already been registered.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when one of the supplied arguments is a null reference (Nothing in VB).
            </exception>
            <remarks>
            <para>
            Note that the use of this method is not encouraged.
            When you use this method, it is most probably an indication that you are not following
            design principles like SOLID and DRY.
            </para>
            <para>
            <h2>Information about these principles</h2>
            <ul>
            <li> <a href="http://stackoverflow.com/questions/9892137/windsor-pulling-transient-objects-from-the-container/9915056#9915056">
            Do I log too much? Do I violate the SOLID principles?
            </a> </li>
            <li> <a href="https://simpleinjector.codeplex.com/wikipage?title=Advanced-scenarios&amp;referringTitle=Advanced-scenarios&amp;ANCHOR#Context-Based-Injection">
            Context Based Injection
            </a> </li>
            <li> <a href="http://en.wikipedia.org/wiki/SOLID">
            SOLID (object-oriented design)
            </a> </li>
            </ul>
            </para>
            </remarks>
        </member>
        <member name="M:SimpleInjector.Advanced.Extensions.ContainerExtensions.RegisterLazy(SimpleInjector.Container)">
            <summary>
            Registers the open generic Lazy&lt;> for all types that happen to be registered in the container.
            </summary>
            <param name="container">The container in which the service will be registered.</param>
        </member>
        <member name="M:SimpleInjector.Advanced.Extensions.ContainerExtensions.RegisterParameterConvention(SimpleInjector.ContainerOptions,SimpleInjector.Advanced.Core.IParameterConvention)">
            <summary>
            Registers conventions for parameters, 
            that can resolve dependencies based on parameter metadata other than Type alone.
            (e.g. by parameter name, by parameter attributes, etc.)
            </summary>
            <param name="options"> The <see cref="C:ContainerOptions"/> of the <see cref="C:Container"/>. </param>
            <param name="convention"> The <see cref="T:SimpleInjector.Advanced.Core.IParameterConvention"/> to register. </param>
        </member>
        <member name="T:SimpleInjector.Advanced.Core.DependencyContext">
            <summary>
            Describes the context in which a service request must be fulfilled.
            </summary>
        </member>
        <member name="P:SimpleInjector.Advanced.Core.DependencyContext.ServiceType">
            <summary>
            Gets the type of service that is being requested.
            </summary>
        </member>
        <member name="P:SimpleInjector.Advanced.Core.DependencyContext.ImplementationType">
            <summary>
            Gets the type to which the created service will be handed over.
            </summary>
        </member>
        <member name="T:SimpleInjector.Advanced.Helpers.StringExtensions">
            <summary>
            Extensions with some useful string methods.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] internal object Test() { return null; }
            internal void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] internal object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            internal void ShowError(string message, params object[] args) { /* do something */ }
            internal void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            internal void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             internal class Foo : INotifyPropertyChanged {
               internal event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               internal string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            internal void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            internal void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            internal bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            internal object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            internal bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            internal class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              internal void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            internal class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            internal class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:JetBrains.Annotations.internalAPIAttribute">
            <summary>
            This attribute is intended to mark internally available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            internal void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            internal ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
    </members>
</doc>
